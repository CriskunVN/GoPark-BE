import { askGeminiAI, getUserInfo } from "../services/chatbot.service.js";
import ChatHistory from "../models/chatHistory.model.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";

export const aiChat = catchAsync(async (req, res, next) => {
  const { message, userId } = req.body;

  console.log("üì• Nh·∫≠n request chatbot:", { 
    message: message?.substring(0, 50) + '...', 
    userId: userId || 'guest'
  });

  // Ki·ªÉm tra v√† validate input v·ªõi th√¥ng b√°o chi ti·∫øt
  if (!message) {
    return next(new AppError("üí¨ Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng. Vui l√≤ng nh·∫≠p c√¢u h·ªèi ho·∫∑c y√™u c·∫ßu c·ªßa b·∫°n.", 400));
  }
  
  if (typeof message !== 'string') {
    return next(new AppError("üìù ƒê·ªãnh d·∫°ng tin nh·∫Øn kh√¥ng h·ª£p l·ªá. Vui l√≤ng g·ª≠i tin nh·∫Øn d·∫°ng vƒÉn b·∫£n.", 400));
  }
  
  if (message.trim() === '') {
    return next(new AppError("‚úçÔ∏è Tin nh·∫Øn kh√¥ng th·ªÉ ch·ªâ ch·ª©a kho·∫£ng tr·∫Øng. H√£y nh·∫≠p n·ªôi dung c·ª• th·ªÉ.", 400));
  }

  if (message.length > 1000) {
    return next(new AppError("üìè Tin nh·∫Øn qu√° d√†i (t·ªëi ƒëa 1000 k√Ω t·ª±). Vui l√≤ng r√∫t g·ªçn n·ªôi dung.", 400));
  }

  const cleanMessage = message.trim();
  let aiReply, userInfo;

  try {
    // L·∫•y th√¥ng tin user tr∆∞·ªõc ƒë·ªÉ x·ª≠ l√Ω l·ªói t·ªët h∆°n
    userInfo = await getUserInfo(userId);
    
    // G·ªçi AI v·ªõi error handling t·ªët h∆°n
    aiReply = await askGeminiAI(cleanMessage, userId);
    
    if (!aiReply || typeof aiReply !== 'string') {
      throw new Error('AI response is invalid');
    }

  } catch (aiError) {
    console.error("‚ùå L·ªói AI processing:", aiError);
    
    // Ph·∫£n h·ªìi th√¢n thi·ªán d·ª±a tr√™n lo·∫°i l·ªói
    let errorMessage = "ü§ñ Xin l·ªói, t√¥i ƒëang g·∫∑p m·ªôt ch√∫t kh√≥ khƒÉn. ";
    
    if (aiError.message?.includes('rate limit') || aiError.message?.includes('429')) {
      errorMessage += "H·ªá th·ªëng ƒëang qu√° t·∫£i. Vui l√≤ng th·ª≠ l·∫°i sau 1-2 ph√∫t. üïê";
    } else if (aiError.message?.includes('network') || aiError.message?.includes('fetch')) {
      errorMessage += "C√≥ v·∫•n ƒë·ªÅ k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i. üåê";
    } else if (aiError.message?.includes('timeout')) {
      errorMessage += "Ph·∫£n h·ªìi m·∫•t qu√° nhi·ªÅu th·ªùi gian. Vui l√≤ng th·ª≠ c√¢u h·ªèi ng·∫Øn g·ªçn h∆°n. ‚è±Ô∏è";
    } else {
      errorMessage += "Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t ho·∫∑c li√™n h·ªá h·ªó tr·ª£ n·∫øu l·ªói ti·∫øp t·ª•c. üõ†Ô∏è";
    }
    
    aiReply = errorMessage;
  }

  // L∆∞u l·ªãch s·ª≠ chat v·ªõi error handling c·∫£i thi·ªán
  try {
    await ChatHistory.create({
      userId: userId || null,
      message: cleanMessage,
      aiReply: aiReply,
      userRole: userInfo?.role || 'guest',
      createdAt: new Date()
    });
    console.log("‚úÖ ƒê√£ l∆∞u l·ªãch s·ª≠ chat");
  } catch (saveError) {
    console.error("‚ö†Ô∏è L·ªói l∆∞u l·ªãch s·ª≠:", saveError);
    // Kh√¥ng l√†m gi√°n ƒëo·∫°n response cho user, ch·ªâ log l·ªói
  }

  // ƒê·∫£m b·∫£o response lu√¥n c√≥ format nh·∫•t qu√°n
  res.status(200).json({
    status: 'success',
    data: {
      reply: {
        role: "assistant",
        content: aiReply
      },
      userInfo: {
        role: userInfo?.role || 'guest',
        name: userInfo?.name || 'Kh√°ch'
      }
    },
    timestamp: new Date().toISOString()
  });
});

export const healthCheck = (req, res) => {
  res.status(200).json({
    status: 'success',
    message: "Chatbot API ƒëang ho·∫°t ƒë·ªông",
    data: {
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development'
    }
  });
};
export const getChatHistory = catchAsync(async (req, res, next) => {
  const { userId } = req.params;
  const { limit = 10 } = req.query;

  if (!userId) {
    return next(new AppError("C·∫ßn c√≥ userId ƒë·ªÉ l·∫•y l·ªãch s·ª≠", 400));
  }

  const chatHistory = await ChatHistory
    .find({ userId })
    .sort({ createdAt: -1 })
    .limit(parseInt(limit));

  res.status(200).json({
    status: 'success',
    results: chatHistory.length,
    data: { chatHistory }
  });
});

export const deleteChatHistory = catchAsync(async (req, res, next) => {
  const { userId } = req.params;

  if (!userId) {
    return next(new AppError("C·∫ßn c√≥ userId ƒë·ªÉ x√≥a l·ªãch s·ª≠", 400));
  }

  const result = await ChatHistory.deleteMany({ userId });

  res.status(200).json({
    status: 'success',
    message: `ƒê√£ x√≥a ${result.deletedCount} tin nh·∫Øn`,
    data: null
  });
});
export const getChatStats = catchAsync(async (req, res, next) => {
  // Th·ªëng k√™ t·ªïng quan v·ªÅ chat
  const stats = await ChatHistory.aggregate([
    {
      $group: {
        _id: "$userRole",
        count: { $sum: 1 }
      }
    },
    {
      $sort: { count: -1 }
    }
  ]);

  const totalChats = await ChatHistory.countDocuments();
  const todayChats = await ChatHistory.countDocuments({
    createdAt: {
      $gte: new Date(new Date().setHours(0, 0, 0, 0))
    }
  });

  res.status(200).json({
    status: 'success',
    data: {
      totalChats,
      todayChats,
      chatsByRole: stats
    }
  });
});

export const getSmartBookingSuggestions = async (req, res) => {
  try {
    const { message, userId } = req.body;
    
    const userInfo = await getUserInfo(userId);
    const bookingInfo = SmartBookingHelper.extractBookingInfo(message, userInfo);
    const result = await SmartBookingHelper.findParkingForBooking(bookingInfo, userInfo);
    
    res.json({
      status: 'success',
      data: {
        type: 'smart_booking_suggestion',
        ...result
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
};

// Endpoint ƒë·ªÉ l·∫•y th√¥ng tin user chi ti·∫øt
export const getUserProfile = async (req, res) => {
  try {
    const { userId } = req.params;
    
    const user = await User.findById(userId).select('userName email phoneNumber role');
    const vehicles = await Vehicle.find({ userId }).select('licensePlate capacity');
    const recentBookings = await Booking.find({ userId })
      .sort({ createdAt: -1 })
      .limit(5)
      .populate('parkingSlotId');
    
    res.json({
      status: 'success',
      data: {
        user,
        vehicles: vehicles || [],
        recentBookings: recentBookings || []
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
};

// Th√™m endpoint ƒë·ªÉ monitor performance
export const getPerformanceMetrics = async (req, res) => {
  try {
    const { getPerformanceMetrics: getMetrics } = await import('../services/ai/geminiService.js');
    const metrics = getMetrics();
    
    res.status(200).json({
      success: true,
      data: {
        ...metrics,
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        timestamp: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error getting performance metrics:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin hi·ªáu su·∫•t'
    });
  }
};