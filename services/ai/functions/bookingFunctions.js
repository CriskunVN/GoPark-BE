// functions/bookingFunctions.js
import Booking from "../../../models/booking.model.js";
import ParkingSlot from "../../../models/parkingSlot.model.js";
import ParkingLot from "../../../models/parkinglot.model.js";

export async function createBooking(parameters) {
  try {
    const { userId, parkingLotId, vehicleNumber, startTime, duration } = parameters;
    
    console.log(`üìÖ Creating booking:`, { userId, parkingLotId, vehicleNumber, startTime, duration });

    // T√¨m available slot
    const availableSlot = await ParkingSlot.findOne({
      parkingLot: parkingLotId,
      status: 'available'
    });

    if (!availableSlot) {
      throw new Error('Hi·ªán kh√¥ng c√≥ ch·ªó tr·ªëng trong b√£i xe n√†y');
    }

    const start = new Date(startTime);
    const end = new Date(start.getTime() + duration * 60 * 60 * 1000);

    // Ki·ªÉm tra conflict
    const conflictingBooking = await Booking.findOne({
      parkingSlotId: availableSlot._id,
      status: { $in: ['pending', 'confirmed'] },
      $or: [
        { startTime: { $lt: end }, endTime: { $gt: start } }
      ]
    });

    if (conflictingBooking) {
      throw new Error('Ch·ªó ƒë·ªó n√†y ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t trong kho·∫£ng th·ªùi gian b·∫°n ch·ªçn');
    }

    // T√≠nh gi√°
    const totalPrice = availableSlot.pricePerHour * duration;

    // T·∫°o booking
    const booking = await Booking.create({
      userId,
      parkingSlotId: availableSlot._id,
      startTime: start,
      endTime: end,
      vehicleNumber,
      totalPrice,
      status: 'pending',
      paymentStatus: 'unpaid'
    });

    // Update slot status
    availableSlot.status = 'booked';
    await availableSlot.save();

    // L·∫•y th√¥ng tin b√£i xe ƒë·ªÉ tr·∫£ v·ªÅ
    const parkingLot = await ParkingLot.findById(parkingLotId);

    return {
      booking: {
        _id: booking._id,
        parkingLotName: parkingLot?.name || 'N/A',
        vehicleNumber: booking.vehicleNumber,
        startTime: booking.startTime,
        endTime: booking.endTime,
        totalPrice: booking.totalPrice,
        status: booking.status
      }
    };
  } catch (error) {
    console.error('‚ùå Error in createBooking:', error);
    throw new Error(`Kh√¥ng th·ªÉ t·∫°o booking: ${error.message}`);
  }
}

export async function getUserBookings(userId, status, limit = 5) {
  try {
    console.log(`üìã Getting bookings for user: ${userId}`, { status, limit });
    
    let query = { userId };
    
    if (status) {
      query.status = status;
    }

    const bookings = await Booking.find(query)
      .populate('parkingSlotId')
      .populate({
        path: 'parkingSlotId',
        populate: {
          path: 'parkingLot',
          select: 'name address'
        }
      })
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .lean();

    const formattedBookings = bookings.map(booking => ({
      _id: booking._id,
      parkingLotName: booking.parkingSlotId?.parkingLot?.name || 'N/A',
      parkingLotAddress: booking.parkingSlotId?.parkingLot?.address || 'N/A',
      vehicleNumber: booking.vehicleNumber,
      startTime: booking.startTime,
      endTime: booking.endTime,
      totalPrice: booking.totalPrice,
      status: booking.status,
      paymentStatus: booking.paymentStatus,
      bookingType: booking.bookingType
    }));

    return {
      bookings: formattedBookings,
      total: formattedBookings.length
    };
  } catch (error) {
    console.error('‚ùå Error in getUserBookings:', error);
    throw new Error('Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ booking');
  }
}

export async function cancelBooking(bookingId, userId) {
  try {
    console.log(`‚ùå Canceling booking: ${bookingId} for user: ${userId}`);
    
    const booking = await Booking.findOne({ _id: bookingId, userId });
    
    if (!booking) {
      throw new Error('Kh√¥ng t√¨m th·∫•y booking');
    }

    if (booking.status === 'cancelled') {
      throw new Error('Booking ƒë√£ ƒë∆∞·ª£c h·ªßy tr∆∞·ªõc ƒë√≥');
    }

    if (booking.status === 'completed') {
      throw new Error('Kh√¥ng th·ªÉ h·ªßy booking ƒë√£ ho√†n th√†nh');
    }

    // Update booking status
    booking.status = 'cancelled';
    await booking.save();

    // Free up the parking slot
    await ParkingSlot.findByIdAndUpdate(booking.parkingSlotId, {
      status: 'available'
    });

    return {
      success: true,
      message: 'ƒê√£ h·ªßy booking th√†nh c√¥ng',
      bookingId: booking._id
    };
  } catch (error) {
    console.error('‚ùå Error in cancelBooking:', error);
    throw new Error(`Kh√¥ng th·ªÉ h·ªßy booking: ${error.message}`);
  }
}