// functions/parkingFunctions.js
import ParkingLot from "../../../models/parkinglot.model.js";
import ParkingSlot from "../../../models/parkingSlot.model.js";
import Booking from "../../../models/booking.model.js";

export async function searchParkingLots(parameters) {
  try {
    const { location, maxPrice, features, limit = 5 } = parameters;
    
    console.log(`üîç Searching parking lots:`, { location, maxPrice, features, limit });

    // T·∫°o query c∆° b·∫£n
    let query = { isActive: true };
    
    // T√¨m theo location (ƒë·ªãa ch·ªâ)
    if (location) {
      query.address = { $regex: location, $options: 'i' };
    }
    
    // Filter theo gi√°
    if (maxPrice) {
      query.pricePerHour = { $lte: maxPrice };
    }

    const parkingLots = await ParkingLot.find(query)
      .limit(parseInt(limit))
      .select('name address pricePerHour zones avtImage image allowedPaymentMethods')
      .lean();

    // Th√™m th√¥ng tin available slots cho m·ªói b√£i xe
    const lotsWithAvailability = await Promise.all(
      parkingLots.map(async (lot) => {
        const totalSlots = lot.zones.reduce((sum, zone) => sum + zone.count, 0);
        
        // ƒê·∫øm s·ªë slot ƒëang ƒë∆∞·ª£c book
        const bookedSlots = await Booking.countDocuments({
          parkingSlotId: { $in: await ParkingSlot.find({ parkingLot: lot._id }).select('_id') },
          status: { $in: ['pending', 'confirmed'] }
        });

        return {
          ...lot,
          totalSlots,
          availableSlots: Math.max(0, totalSlots - bookedSlots),
          isAvailable: totalSlots - bookedSlots > 0
        };
      })
    );

    return lotsWithAvailability;
  } catch (error) {
    console.error('‚ùå Error in searchParkingLots:', error);
    throw new Error('Kh√¥ng th·ªÉ t√¨m ki·∫øm b√£i xe');
  }
}

export async function getParkingDetails(parkingLotId) {
  try {
    console.log(`üìã Getting details for parking lot: ${parkingLotId}`);
    
    const parkingLot = await ParkingLot.findById(parkingLotId)
      .populate('parkingOwner', 'userName email')
      .lean();

    if (!parkingLot) {
      throw new Error('Kh√¥ng t√¨m th·∫•y b√£i xe');
    }

    // L·∫•y th√¥ng tin slots
    const slots = await ParkingSlot.find({ parkingLot: parkingLotId });
    
    // Th·ªëng k√™ availability
    const availableSlots = slots.filter(slot => slot.status === 'available').length;
    const totalSlots = slots.length;

    return {
      ...parkingLot,
      slots: {
        total: totalSlots,
        available: availableSlots,
        booked: totalSlots - availableSlots
      },
      zones: parkingLot.zones || []
    };
  } catch (error) {
    console.error('‚ùå Error in getParkingDetails:', error);
    throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin b√£i xe');
  }
}

export async function checkAvailability(parkingLotId, startTime, duration) {
  try {
    console.log(`‚è∞ Checking availability:`, { parkingLotId, startTime, duration });
    
    const start = new Date(startTime);
    const end = new Date(start.getTime() + duration * 60 * 60 * 1000); // duration in hours

    // L·∫•y t·∫•t c·∫£ slots c·ªßa b√£i xe
    const slots = await ParkingSlot.find({ parkingLot: parkingLotId });
    
    // Ki·ªÉm tra slots n√†o available trong kho·∫£ng th·ªùi gian n√†y
    const availableSlots = await Promise.all(
      slots.map(async (slot) => {
        const conflictingBookings = await Booking.countDocuments({
          parkingSlotId: slot._id,
          status: { $in: ['pending', 'confirmed'] },
          $or: [
            { startTime: { $lt: end }, endTime: { $gt: start } }
          ]
        });

        return {
          slotId: slot._id,
          slotNumber: slot.slotNumber,
          zone: slot.zone,
          pricePerHour: slot.pricePerHour,
          isAvailable: conflictingBookings === 0
        };
      })
    );

    const availableCount = availableSlots.filter(slot => slot.isAvailable).length;
    
    return {
      parkingLotId,
      startTime: start,
      endTime: end,
      duration,
      availableSlots: availableCount,
      totalSlots: slots.length,
      slots: availableSlots
    };
  } catch (error) {
    console.error('‚ùå Error in checkAvailability:', error);
    throw new Error('Kh√¥ng th·ªÉ ki·ªÉm tra t√¨nh tr·∫°ng ch·ªó tr·ªëng');
  }
}