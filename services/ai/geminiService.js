import dotenv from "dotenv";
import { callFunction } from "./functions/functionCaller.js";
dotenv.config({ path: "./config.env" });

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

// Cache m·∫°nh m·∫Ω h∆°n
const responseCache = new Map();
const CACHE_DURATION = 30000; // TƒÉng l√™n 30 gi√¢y
const userRequestCache = new Map(); // Cache theo user

// Rate limiting m·∫°nh m·∫Ω
const requestQueue = [];
let isProcessing = false;
const MAX_REQUESTS_PER_MINUTE = 10; // Gi·∫£m m·∫°nh
const MAX_REQUESTS_PER_USER = 5; // Gi·ªõi h·∫°n per user
const MAX_CACHE_SIZE = 1000; // Gi·ªõi h·∫°n cache size
let requestCount = 0;
let lastResetTime = Date.now();

// User request tracking
const userRequestCount = new Map();

// Frequent questions cache
const frequentQuestionsCache = new Map();

// Performance metrics tracking
const performanceMetrics = {
  totalRequests: 0,
  cacheHits: 0,
  cacheMisses: 0,
  apiCalls: 0,
  localProcessing: 0,
  averageResponseTime: 0,
  errors: 0
};
 // keywords n√¢ng cao cho x·ª≠ l√Ω c·ª•c b·ªô
const ENHANCED_KEYWORD_HANDLING = {
  // Keywords cho ƒë·∫∑t ch·ªó
  booking: ['ƒë·∫∑t', 'book', 'booking', 'thu√™ ch·ªó', 'g·ª≠i xe', 'ƒë·∫≠u xe', 'ch·ªó ƒë·ªó', 'b√£i ƒë·∫≠u'],
  
  // Keywords cho th√¥ng tin c√° nh√¢n
  personal: ['t√¥i', 'c·ªßa t√¥i', 'th√¥ng tin', 'h·ªì s∆°', 't√™n t√¥i', 'xe t√¥i'],
  
  // Keywords cho l·ªãch s·ª≠
  history: ['l·ªãch s·ª≠', 'ƒë√£ ƒë·∫∑t', 'tr∆∞·ªõc ƒë√¢y', 'c≈©', 'history'],
  
  // Keywords cho t√¨m ki·∫øm
  search: ['t√¨m', 'ki·∫øm', '·ªü ƒë√¢u', 'g·∫ßn ƒë√¢y', 'location'],
  
  // Keywords cho ch√†o h·ªèi
  greeting: ['xin ch√†o', 'hello', 'hi', 'ch√†o', 'ch√†o b·∫°n']
};
 // Frequent patterns v√† responses
const FREQUENT_PATTERNS = [
  {
    pattern: /^(xin ch√†o|hello|hi|ch√†o)$/i,
    response: "üëã Xin ch√†o! T√¥i l√† tr·ª£ l√Ω GoPark. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m b√£i xe, xem th·ªëng k√™ v√† qu·∫£n l√Ω ƒë·∫∑t ch·ªó!"
  },
  {
    pattern: /^(c·∫£m ∆°n|thanks|thank you)$/i,
    response: "üòä Kh√¥ng c√≥ g√¨! T√¥i r·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n. C·∫ßn g√¨ n·ªØa kh√¥ng?"
  },
  {
    pattern: /^(t·∫°m bi·ªát|bye|goodbye)$/i,
    response: "üëã T·∫°m bi·ªát b·∫°n! H·∫πn g·∫∑p l·∫°i. Ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh!"
  },
  {
    pattern: /^(b·∫°n l√† ai|ai l√† b·∫°n|gi·ªõi thi·ªáu)$/i,
    response: "ü§ñ T√¥i l√† tr·ª£ l√Ω AI c·ªßa GoPark - h·ªá th·ªëng ƒë·∫∑t ch·ªó ƒë·ªó xe th√¥ng minh. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m b√£i xe, xem th·ªëng k√™ v√† qu·∫£n l√Ω booking!"
  }
];

// Fallback responses
const FALLBACK_RESPONSES = {
  greeting: "üëã Xin ch√†o! T√¥i l√† tr·ª£ l√Ω GoPark. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ T√¨m b√£i xe\n‚Ä¢ ƒê·∫∑t ch·ªó\n‚Ä¢ Xem l·ªãch s·ª≠\n‚Ä¢ Th·ªëng k√™",
  search: "üîç H√£y cho t√¥i bi·∫øt khu v·ª±c b·∫°n mu·ªën t√¨m b√£i xe (v√≠ d·ª•: 't√¨m b√£i xe ·ªü H·∫£i Ch√¢u')",
  booking: "üìÖ ƒê·ªÉ ƒë·∫∑t ch·ªó, vui l√≤ng cho bi·∫øt:\n‚Ä¢ Khu v·ª±c\n‚Ä¢ Th·ªùi gian\n‚Ä¢ Bi·ªÉn s·ªë xe",
  history: "üìã Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem l·ªãch s·ª≠ ƒë·∫∑t ch·ªó c·ªßa b·∫°n",
  error: "‚ö†Ô∏è Hi·ªán t·∫°i t√¥i ƒëang b·∫≠n. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."
};

export async function callGeminiAI(userInfo, message) {
  const startTime = Date.now();
  performanceMetrics.totalRequests++;
  
  // Ki·ªÉm tra frequent questions tr∆∞·ªõc
  const frequentResponse = checkFrequentQuestions(message);
  if (frequentResponse) {
    performanceMetrics.cacheHits++;
    updatePerformanceMetrics(startTime);
    return frequentResponse;
  }

  // TƒÉng c∆∞·ªùng rate limiting per user
  if (!await checkRateLimit(userInfo.userId)) {
    return getFallbackResponse(message);
  }

  // Multi-layer caching
  const cacheKey = generateCacheKey(userInfo, message);
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    performanceMetrics.cacheHits++;
    updatePerformanceMetrics(startTime);
    console.log('üéØ Using cached response');
    return cached.response;
  }

  performanceMetrics.cacheMisses++;

  // ∆Øu ti√™n x·ª≠ l√Ω c·ª•c b·ªô tr∆∞·ªõc khi g·ªçi API
  const localResponse = await processLocally(userInfo, message);
  if (localResponse) {
    performanceMetrics.localProcessing++;
    cacheResponse(cacheKey, localResponse);
    updatePerformanceMetrics(startTime);
    return localResponse;
  }

  // Ch·ªâ g·ªçi API khi th·ª±c s·ª± c·∫ßn
  performanceMetrics.apiCalls++;
  const result = await processWithAI(userInfo, message, cacheKey);
  updatePerformanceMetrics(startTime);
  return result;
}

// Improved caching functions
function generateCacheKey(userInfo, message) {
  const normalizedMessage = message.toLowerCase().trim().replace(/\s+/g, ' ');
  return `${userInfo.userId || 'guest'}-${normalizedMessage}`;
}

function getCachedResponse(cacheKey) {
  const cached = responseCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached;
  }
  
  // Check frequent questions cache
  const FREQUENT_CACHE_DURATION = 300000; // 5 ph√∫t
  const frequentCached = frequentQuestionsCache.get(cacheKey);
  if (frequentCached && Date.now() - frequentCached.timestamp < FREQUENT_CACHE_DURATION) {
    return frequentCached;
  }
  
  return null;
}

function checkFrequentQuestions(message) {
  const lowerMessage = message.toLowerCase();
  
  for (const pattern of FREQUENT_PATTERNS) {
    if (pattern.pattern.test(lowerMessage)) {
      // Cache frequent response
      const cacheKey = `frequent-${lowerMessage}`;
      frequentQuestionsCache.set(cacheKey, {
        response: pattern.response,
        timestamp: Date.now()
      });
      return pattern.response;
    }
  }
  
  return null;
}

// Th√™m v√†o response t·ª´ AI:
function formatAIResponse(aiText, detectedIntent) {
  return {
    content: aiText,
    context: detectedIntent, // "search", "booking", "error", etc.
    suggestedActions: getSuggestedActions(detectedIntent)
  };
}

function getSuggestedActions(intent) {
  const actions = {
    search_result: ["ƒê·∫∑t ch·ªó t·∫°i b√£i n√†y", "Xem b√£i kh√°c", "Chi ti·∫øt b√£i xe"],
    booking_pending: ["X√°c nh·∫≠n ƒë·∫∑t ch·ªó", "Thay ƒë·ªïi th·ªùi gian", "Ch·ªçn b√£i kh√°c"],
    need_auth: ["H∆∞·ªõng d·∫´n ƒëƒÉng nh·∫≠p", "ƒêƒÉng k√Ω m·ªõi"],
    error: ["Th·ª≠ l·∫°i", "H·ªèi c√°ch kh√°c", "Li√™n h·ªá h·ªó tr·ª£"]
  };
  
  return actions[intent] || actions.search_result;
}


function updatePerformanceMetrics(startTime) {
  const responseTime = Date.now() - startTime;
  performanceMetrics.averageResponseTime = 
    (performanceMetrics.averageResponseTime * (performanceMetrics.totalRequests - 1) + responseTime) / 
    performanceMetrics.totalRequests;
}

// Enhanced rate limiting v·ªõi per-user limits
async function checkRateLimit(userId) {
  const now = Date.now();
  
  // Reset counters every minute
  if (now - lastResetTime > 60000) {
    requestCount = 0;
    userRequestCount.clear();
    lastResetTime = now;
  }
  
  // Global rate limit
  if (requestCount >= MAX_REQUESTS_PER_MINUTE) {
    console.log('‚ö†Ô∏è Global rate limit exceeded');
    return false;
  }
  
  // Per-user rate limit
  if (userId) {
    const userCount = userRequestCount.get(userId) || 0;
    if (userCount >= MAX_REQUESTS_PER_USER) {
      console.log(`‚ö†Ô∏è User rate limit exceeded for ${userId}`);
      return false;
    }
    userRequestCount.set(userId, userCount + 1);
  }
  
  requestCount++;
  return true;
}

// Cache management v·ªõi size limits
function cacheResponse(key, response, isFrequent = false) {
  const cacheToUse = isFrequent ? frequentQuestionsCache : responseCache;
  
  // Manage cache size
  if (cacheToUse.size >= MAX_CACHE_SIZE) {
    // Remove oldest entries (simple LRU)
    const oldestKey = cacheToUse.keys().next().value;
    cacheToUse.delete(oldestKey);
  }
  
  cacheToUse.set(key, {
    response: response,
    timestamp: Date.now()
  });
}

// Performance monitoring endpoint data
export function getPerformanceMetrics() {
  return {
    ...performanceMetrics,
    cacheHitRate: performanceMetrics.cacheHits / (performanceMetrics.cacheHits + performanceMetrics.cacheMisses) * 100,
    cacheSize: responseCache.size,
    frequentCacheSize: frequentQuestionsCache.size,
    timestamp: Date.now()
  };
}

// C·∫£i thi·ªán processWithAI v·ªõi better error handling
async function processWithAI(userInfo, message, cacheKey) {
  try {
    console.log(`ü§ñ Calling Gemini AI for: "${message.substring(0, 50)}..."`);
    
    // L·∫•y memory v√† t·∫°o contextual response
    const memory = getConversationMemory(userInfo?.userId);
    const contextualIntro = generateContextualResponse(userInfo, message, memory);
    
    const requestBody = {
      contents: [{
        parts: [{
          text: `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa GoPark - h·ªá th·ªëng ƒë·∫∑t ch·ªó ƒë·ªó xe th√¥ng minh.

TH√îNG TIN NG∆Ø·ªúI D√ôNG:
- Role: ${userInfo?.role || 'guest'}
- User ID: ${userInfo?.userId || 'kh√¥ng c√≥'}

PERSONALITY GUIDELINES:
- Th√¢n thi·ªán, t·ª± nhi√™n v√† kh√¥ng m√°y m√≥c
- S·ª≠ d·ª•ng emoji ph√π h·ª£p nh∆∞ng kh√¥ng spam
- Ph·∫£n h·ªìi ng·∫Øn g·ªçn, s√∫c t√≠ch (d∆∞·ªõi 100 t·ª´)
- Th·ªÉ hi·ªán c·∫£m x√∫c v√† s·ª± ƒë·ªìng c·∫£m khi c·∫ßn thi·∫øt
- Tr√°nh l·∫∑p l·∫°i c√πng m·ªôt c√°ch di·ªÖn ƒë·∫°t

CONTEXTUAL INTRO: "${contextualIntro}"

H∆Ø·ªöNG D·∫™N PH·∫¢N H·ªíI:
1. B·∫Øt ƒë·∫ßu v·ªõi contextual intro n·∫øu ph√π h·ª£p
2. Tr·∫£ l·ªùi tr·ª±c ti·∫øp v√† h·ªØu √≠ch
3. N·∫øu c·∫ßn function call, ch·ªâ d√πng khi user y√™u c·∫ßu r√µ r√†ng
4. ∆Øu ti√™n tr·∫£ l·ªùi tr·ª±c ti·∫øp thay v√¨ g·ªçi function

FUNCTIONS AVAILABLE: search_parking_lots, get_user_bookings, get_user_vehicles, create_booking

Tin nh·∫Øn c·ªßa user: "${message}"`
        }]
      }],
      generationConfig: {
        temperature: 0.4, // TƒÉng ƒë·ªÉ c√≥ ph·∫£n h·ªìi t·ª± nhi√™n h∆°n
        maxOutputTokens: 150,
        topK: 20,
        topP: 0.8 // TƒÉng ƒë·ªÉ c√≥ s·ª± ƒëa d·∫°ng h∆°n
      }
    };

    const response = await fetch(GEMINI_URL + `?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
      signal: AbortSignal.timeout(8000)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå Gemini API Error ${response.status}:`, errorText);
      
      if (response.status === 429) {
        return getFallbackResponse(message, 'RATE_LIMIT');
      } else if (response.status >= 500) {
        return getFallbackResponse(message, 'SERVER_ERROR');
      } else {
        return getFallbackResponse(message, 'API_ERROR');
      }
    }

    const data = await response.json();
    console.log('üîç Gemini response structure:', JSON.stringify(data, null, 2));

    // X·ª≠ l√Ω response v·ªõi better error handling
    if (data.candidates && data.candidates.length > 0) {
      const candidate = data.candidates[0];
      
      if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
        const part = candidate.content.parts[0];
        
        if (part.text) {
          const aiResponse = part.text.trim();
          console.log(`‚úÖ AI Response: "${aiResponse}"`);
          
          // C·∫≠p nh·∫≠t memory v·ªõi cu·ªôc h·ªôi tho·∫°i m·ªõi
          updateConversationMemory(userInfo?.userId, message, aiResponse, {
            timestamp: Date.now(),
            emotion: analyzeEmotion(message.toLowerCase()),
            intent: analyzeIntent(message.toLowerCase())
          });
          
          // Cache successful response
          cacheResponse(cacheKey, aiResponse);
          return aiResponse;
        }
        
        if (part.functionCall) {
          console.log('üîß Function call detected:', part.functionCall);
          return await handleFunctionCall(part.functionCall, userInfo);
        }
      }
      
      // Ki·ªÉm tra finishReason ƒë·ªÉ hi·ªÉu t·∫°i sao kh√¥ng c√≥ content
      if (candidate.finishReason) {
        console.log('‚ö†Ô∏è Finish reason:', candidate.finishReason);
        
        switch (candidate.finishReason) {
          case 'SAFETY':
            return getRandomResponse(AI_PERSONALITY.conversationStyle.apologetic) + " Vui l√≤ng th·ª≠ c√¢u h·ªèi kh√°c.";
          case 'MAX_TOKENS':
            return getRandomResponse(AI_PERSONALITY.conversationStyle.thinking) + " Vui l√≤ng h·ªèi c·ª• th·ªÉ h∆°n.";
          case 'RECITATION':
            return getRandomResponse(AI_PERSONALITY.conversationStyle.casual_responses) + " H√£y di·ªÖn ƒë·∫°t theo c√°ch kh√°c nh√©.";
          default:
            return getFallbackResponse(message, 'INCOMPLETE_RESPONSE');
        }
      }
    }

    // N·∫øu kh√¥ng c√≥ candidates ho·∫∑c content
    console.error('‚ùå No valid response from Gemini:', data);
    return getFallbackResponse(message, 'NO_CONTENT');

  } catch (error) {
    console.error('‚ùå Error in processWithAI:', error);
    
    if (error.name === 'AbortError' || error.message.includes('timeout')) {
      return getFallbackResponse(message, 'TIMEOUT');
    } else if (error.message.includes('fetch')) {
      return getFallbackResponse(message, 'NETWORK_ERROR');
    } else {
      return getFallbackResponse(message, 'UNKNOWN_ERROR');
    }
  }
}

function getFallbackResponse(message, errorType = 'GENERAL') {
  const lowerMessage = message.toLowerCase();
  
  // Ph·∫£n h·ªìi d·ª±a tr√™n lo·∫°i l·ªói v·ªõi personality
  switch (errorType) {
    case 'RATE_LIMIT':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.apologetic) + " H·ªá th·ªëng ƒëang b·∫≠n, vui l√≤ng th·ª≠ l·∫°i sau 1 ph√∫t. üïê";
    case 'TIMEOUT':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.thinking) + " Ph·∫£n h·ªìi m·∫•t qu√° nhi·ªÅu th·ªùi gian. Vui l√≤ng th·ª≠ l·∫°i. ‚è±Ô∏è";
    case 'NETWORK_ERROR':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " C√≥ v·∫ª nh∆∞ c√≥ v·∫•n ƒë·ªÅ k·∫øt n·ªëi. Vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i. üåê";
    case 'SERVER_ERROR':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.apologetic) + " M√°y ch·ªß AI t·∫°m th·ªùi g·∫∑p s·ª± c·ªë. Vui l√≤ng th·ª≠ l·∫°i sau. üîß";
    case 'API_ERROR':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " C√≥ l·ªói x·∫£y ra. Vui l√≤ng li√™n h·ªá admin n·∫øu l·ªói ti·∫øp t·ª•c. ‚ö†Ô∏è";
    case 'NO_CONTENT':
    case 'INCOMPLETE_RESPONSE':
      return getRandomResponse(AI_PERSONALITY.conversationStyle.casual_responses) + " T√¥i kh√¥ng hi·ªÉu r√µ c√¢u h·ªèi. B·∫°n c√≥ th·ªÉ h·ªèi c√°ch kh√°c kh√¥ng? ü§î";
    default:
      break;
  }
  
  // Ph·∫£n h·ªìi d·ª±a tr√™n n·ªôi dung tin nh·∫Øn v·ªõi personality
  if (ENHANCED_KEYWORD_HANDLING.greeting.some(keyword => lowerMessage.includes(keyword))) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.greeting);
  }
  
  if (ENHANCED_KEYWORD_HANDLING.search.some(keyword => lowerMessage.includes(keyword))) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement) + " " + FALLBACK_RESPONSES.search;
  }
  
  if (ENHANCED_KEYWORD_HANDLING.booking.some(keyword => lowerMessage.includes(keyword))) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.thinking) + " " + FALLBACK_RESPONSES.booking;
  }
  
  if (ENHANCED_KEYWORD_HANDLING.history.some(keyword => lowerMessage.includes(keyword))) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " " + FALLBACK_RESPONSES.history;
  }

  // TH√äM C√ÅC PH·∫¢N H·ªíI M·ªöI V√ÄO ƒê√ÇY:
  if (lowerMessage.includes('gi·ªù') || lowerMessage.includes('m·ªü c·ª≠a')) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement) + " H·∫ßu h·∫øt b√£i xe ho·∫°t ƒë·ªông 24/7. M·ªôt s·ªë b√£i c√≥ gi·ªù m·ªü c·ª≠a ri√™ng, t√¥i s·∫Ω ki·ªÉm tra khi b·∫°n ch·ªçn b√£i c·ª• th·ªÉ. üïê";
  }

  if (lowerMessage.includes('thanh to√°n') || lowerMessage.includes('momo')) {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.casual_responses) + " GoPark h·ªó tr·ª£ thanh to√°n: Ti·ªÅn m·∫∑t, MoMo, ZaloPay, v√† th·∫ª ng√¢n h√†ng. üí≥";
  }

  // Fallback cu·ªëi c√πng
  return getRandomResponse(AI_PERSONALITY.conversationStyle.greeting) + " T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ T√¨m b√£i xe g·∫ßn ƒë√¢y üîç\n‚Ä¢ ƒê·∫∑t ch·ªó tr∆∞·ªõc üìÖ\n‚Ä¢ Xem l·ªãch s·ª≠ booking üìã\n‚Ä¢ Th√¥ng tin xe ƒë√£ ƒëƒÉng k√Ω üöó\n\nB·∫°n c·∫ßn h·ªó tr·ª£ g√¨?";
}

// X·ª≠ l√Ω function calls
async function handleFunctionCall(functionCall, userInfo) {
  try {
    console.log('üîß Processing function call:', functionCall);
    
    const { name: functionName, args } = functionCall;
    const parameters = args || {};
    
    // Th√™m userId v√†o parameters n·∫øu c·∫ßn
    if (userInfo?.userId && !parameters.userId) {
      parameters.userId = userInfo.userId;
    }
    
    const result = await callFunction(functionName, parameters, userInfo?.role || 'guest');
    
    if (result.success) {
      return formatFunctionResult(functionName, result);
    } else {
      return `‚ùå ${result.error || 'Kh√¥ng th·ªÉ th·ª±c hi·ªán y√™u c·∫ßu n√†y.'}`;
    }
  } catch (error) {
    console.error('‚ùå Error in handleFunctionCall:', error);
    return "‚ö†Ô∏è C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i.";
  }
}

// Format k·∫øt qu·∫£ function call
function formatFunctionResult(functionName, result) {
  switch (functionName) {
    case 'search_parking_lots':
      if (result.data && result.data.length > 0) {
        return `üè¢ T√¨m th·∫•y ${result.data.length} b√£i xe:\n` +
          result.data.map((lot, i) => 
            `${i + 1}. ${lot.name}\n   üìç ${lot.address}\n   üí∞ ${lot.pricePerHour?.toLocaleString() || 'N/A'}ƒë/gi·ªù`
          ).join('\n\n');
      }
      return "‚ùå Kh√¥ng t√¨m th·∫•y b√£i xe n√†o ph√π h·ª£p.";
      
    case 'get_user_bookings':
      if (result.data?.bookings && result.data.bookings.length > 0) {
        return `üìã L·ªãch s·ª≠ booking c·ªßa b·∫°n:\n` +
          result.data.bookings.map((booking, i) => 
            `${i + 1}. ${booking.parkingLotName}\n   üöó ${booking.vehicleNumber}\n   üìÖ ${booking.startTime}\n   üí∞ ${booking.totalPrice}ƒë`
          ).join('\n\n');
      }
      return "üì≠ B·∫°n ch∆∞a c√≥ booking n√†o.";
      
    case 'get_user_vehicles':
      if (result.data?.vehicles && result.data.vehicles.length > 0) {
        return `üöó Xe ƒë√£ ƒëƒÉng k√Ω:\n` +
          result.data.vehicles.map((vehicle, i) => 
            `${i + 1}. ${vehicle.licensePlate} (${vehicle.capacity || 'N/A'} ch·ªó)`
          ).join('\n');
      }
      return "üö´ B·∫°n ch∆∞a ƒëƒÉng k√Ω xe n√†o.";
      
    case 'create_booking':
      if (result.data?.booking) {
        const booking = result.data.booking;
        return `‚úÖ ƒê·∫∑t ch·ªó th√†nh c√¥ng!\nüìã ${booking.parkingLotName}\nüöó ${booking.vehicleNumber}\nüìÖ ${booking.startTime}\nüí∞ ${booking.totalPrice}`;
      }
      return "‚úÖ ƒê·∫∑t ch·ªó th√†nh c√¥ng!";
      
    default:
      return result.message || "‚úÖ Th√†nh c√¥ng!";
  }
}


// AI Personality v√† Context System
const AI_PERSONALITY = {
  name: "GoPark Assistant",
  traits: {
    friendly: true,
    helpful: true,
    professional: true,
    empathetic: true,
    conversational: true,
    adaptive: true
  },
  conversationStyle: {
    greeting: [
      "üëã Xin ch√†o! T√¥i l√† tr·ª£ l√Ω GoPark, r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n h√¥m nay!",
      "üåü Ch√†o b·∫°n! T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m b√£i xe ho·∫∑c ƒë·∫∑t ch·ªó ngay b√¢y gi·ªù.",
      "üòä Hello! T√¥i l√† AI assistant c·ªßa GoPark, s·∫µn s√†ng h·ªó tr·ª£ b·∫°n!",
      "üöó Ch√†o b·∫°n! C·∫ßn t√¨m ch·ªó ƒë·ªó xe hay c√≥ th·ªÉ gi√∫p g√¨ kh√°c kh√¥ng?",
      "‚ú® Xin ch√†o! H√¥m nay t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n ƒëi·ªÅu g√¨ v·ªÅ vi·ªác ƒë·ªó xe?"
    ],
    encouragement: [
      "Tuy·ªát v·ªùi! T√¥i s·∫Ω gi√∫p b·∫°n ngay.",
      "ƒê∆∞·ª£c r·ªìi! ƒê·ªÉ t√¥i x·ª≠ l√Ω cho b·∫°n.",
      "OK! T√¥i hi·ªÉu r·ªìi, h√£y ƒë·ªÉ t√¥i t√¨m gi·∫£i ph√°p t·ªët nh·∫•t.",
      "R·∫•t t·ªët! T√¥i s·∫Ω t√¨m cho b·∫°n nh·ªØng l·ª±a ch·ªçn ph√π h·ª£p nh·∫•t.",
      "T√¥i s·∫Ω gi√∫p b·∫°n gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y ngay!"
    ],
    empathy: [
      "T√¥i hi·ªÉu b·∫°n ƒëang c·∫ßn t√¨m ch·ªó ƒë·ªó xe g·∫•p.",
      "ƒê·ª´ng lo, t√¥i s·∫Ω gi√∫p b·∫°n t√¨m ƒë∆∞·ª£c ch·ªó ph√π h·ª£p.",
      "T√¥i s·∫Ω c·ªë g·∫Øng t√¨m gi·∫£i ph√°p t·ªët nh·∫•t cho b·∫°n.",
      "T√¥i hi·ªÉu vi·ªác t√¨m ch·ªó ƒë·ªó xe c√≥ th·ªÉ kh√≥ khƒÉn, ƒë·ªÉ t√¥i h·ªó tr·ª£ b·∫°n.",
      "Kh√¥ng sao c·∫£, t√¥i ·ªü ƒë√¢y ƒë·ªÉ gi√∫p b·∫°n t√¨m ra gi·∫£i ph√°p."
    ],
    casual_responses: [
      "·ªí, th√∫ v·ªã ƒë·∫•y!",
      "Hmm, ƒë·ªÉ t√¥i xem n√†o...",
      "Ah, t√¥i hi·ªÉu r·ªìi!",
      "ƒê∆∞·ª£c th√¥i, kh√¥ng v·∫•n ƒë·ªÅ g√¨!",
      "Oke, t√¥i s·∫Ω gi√∫p b·∫°n ngay!"
    ],
    thinking: [
      "ƒê·ªÉ t√¥i suy nghƒ© m·ªôt ch√∫t...",
      "Hmm, t√¥i ƒëang t√¨m hi·ªÉu...",
      "Ch·ªù t√¥i ki·ªÉm tra th√¥ng tin nh√©...",
      "T√¥i ƒëang x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n...",
      "M·ªôt gi√¢y, t√¥i ƒëang t√¨m ki·∫øm..."
    ],
    apologetic: [
      "Xin l·ªói v√¨ s·ª± b·∫•t ti·ªán n√†y.",
      "R·∫•t ti·∫øc, c√≥ v·∫ª nh∆∞ c√≥ ch√∫t v·∫•n ƒë·ªÅ.",
      "√îi, t√¥i xin l·ªói v·ªÅ ƒëi·ªÅu n√†y.",
      "Xin l·ªói b·∫°n, t√¥i s·∫Ω c·ªë g·∫Øng h·ªó tr·ª£ t·ªët h∆°n.",
      "Th·∫≠t s·ª± xin l·ªói, ƒë·ªÉ t√¥i th·ª≠ c√°ch kh√°c."
    ],
    confirmation: [
      "B·∫°n c√≥ ch·∫Øc ch·∫Øn kh√¥ng?",
      "T√¥i hi·ªÉu ƒë√∫ng ch∆∞a?",
      "V·∫≠y l√† b·∫°n mu·ªën...?",
      "ƒê·ªÉ t√¥i x√°c nh·∫≠n l·∫°i nh√©:",
      "B·∫°n c√≥ mu·ªën t√¥i ti·∫øp t·ª•c kh√¥ng?"
    ]
  },
  responsePatterns: {
    // Tr√°nh l·∫∑p l·∫°i c√πng m·ªôt pattern
    avoid_repetition: true,
    // S·ª≠ d·ª•ng emoji m·ªôt c√°ch t·ª± nhi√™n
    natural_emoji: true,
    // Thay ƒë·ªïi c√°ch di·ªÖn ƒë·∫°t
    vary_expression: true,
    // Ph·∫£n h·ªìi theo context
    contextual: true
  }
};

// Context Memory System
const conversationMemory = new Map();
const MEMORY_DURATION = 30 * 60 * 1000; // 30 ph√∫t

function updateConversationMemory(userId, message, response, context = {}) {
  if (!userId) return;
  
  const userMemory = conversationMemory.get(userId) || {
    conversations: [],
    preferences: {},
    lastInteraction: null,
    context: {}
  };
  
  userMemory.conversations.push({
    timestamp: Date.now(),
    userMessage: message,
    aiResponse: response,
    context: context
  });
  
  // Gi·ªØ ch·ªâ 10 cu·ªôc h·ªôi tho·∫°i g·∫ßn nh·∫•t
  if (userMemory.conversations.length > 10) {
    userMemory.conversations = userMemory.conversations.slice(-10);
  }
  
  userMemory.lastInteraction = Date.now();
  userMemory.context = { ...userMemory.context, ...context };
  
  conversationMemory.set(userId, userMemory);
}

function getConversationMemory(userId) {
  if (!userId) return null;
  
  const memory = conversationMemory.get(userId);
  if (!memory || Date.now() - memory.lastInteraction > MEMORY_DURATION) {
    return null;
  }
  
  return memory;
}

function getRandomResponse(responseArray) {
  return responseArray[Math.floor(Math.random() * responseArray.length)];
}

function generateContextualResponse(userInfo, message, memory = null) {
  const lowerMessage = message.toLowerCase();
  
  // Ph√¢n t√≠ch c·∫£m x√∫c v√† √Ω ƒë·ªãnh
  const intent = analyzeIntent(lowerMessage);
  const emotion = analyzeEmotion(lowerMessage);
  
  // T·∫°o ph·∫£n h·ªìi d·ª±a tr√™n context
  let response = "";
  
  // X·ª≠ l√Ω memory v√† context
  if (memory && memory.conversations.length > 0) {
    const lastConversation = memory.conversations[memory.conversations.length - 1];
    const timeSinceLastChat = Date.now() - lastConversation.timestamp;
    
    if (timeSinceLastChat < 5 * 60 * 1000) { // 5 ph√∫t
      response += "T√¥i nh·ªõ ch√∫ng ta v·ª´a n√≥i chuy·ªán. ";
    } else if (timeSinceLastChat > 30 * 60 * 1000) { // 30 ph√∫t
      response += getRandomResponse(AI_PERSONALITY.conversationStyle.greeting) + " ";
    }
  }
  
  // Ph·∫£n h·ªìi d·ª±a tr√™n c·∫£m x√∫c
  if (emotion === 'negative') {
    response += getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " ";
  } else if (emotion === 'positive') {
    response += getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement) + " ";
  }
  
  // Ph·∫£n h·ªìi d·ª±a tr√™n urgency
  if (intent.urgency === 'high') {
    response += getRandomResponse(AI_PERSONALITY.conversationStyle.thinking) + " ";
  }
  
  // Ph·∫£n h·ªìi d·ª±a tr√™n lo·∫°i tin nh·∫Øn
  if (intent.type === 'greeting') {
    return getRandomResponse(AI_PERSONALITY.conversationStyle.greeting);
  } else if (intent.type === 'question') {
    response += getRandomResponse(AI_PERSONALITY.conversationStyle.thinking) + " ";
  }
  
  // Th√™m t√≠nh l·ªãch s·ª±
  if (intent.politeness === 'high') {
    response += "C·∫£m ∆°n b·∫°n ƒë√£ l·ªãch s·ª±. ";
  }
  
  return response.trim();
}

function analyzeIntent(message) {
  const urgencyKeywords = ['g·∫•p', 'nhanh', 'kh·∫©n c·∫•p', 'ngay', 'urgent'];
  const politeKeywords = ['xin', 'vui l√≤ng', 'please', 'c·∫£m ∆°n', 'thank'];
  
  return {
    urgency: urgencyKeywords.some(k => message.includes(k)) ? 'high' : 'normal',
    politeness: politeKeywords.some(k => message.includes(k)) ? 'high' : 'normal',
    type: detectMessageType(message)
  };
}

function analyzeEmotion(message) {
  const positiveKeywords = ['t·ªët', 'hay', 'tuy·ªát', 'c·∫£m ∆°n', 'good', 'great'];
  const negativeKeywords = ['t·ªá', 'kh√≥', 'kh√¥ng ƒë∆∞·ª£c', 'l·ªói', 'bad', 'error'];
  
  if (positiveKeywords.some(k => message.includes(k))) return 'positive';
  if (negativeKeywords.some(k => message.includes(k))) return 'negative';
  return 'neutral';
}

function detectMessageType(message) {
  if (message.includes('?')) return 'question';
  if (message.includes('!')) return 'exclamation';
  if (message.includes('xin ch√†o') || message.includes('hello')) return 'greeting';
  return 'statement';
}


// Enhanced local processing v·ªõi AI-like responses
async function processLocally(userInfo, message) {
  const lowerMessage = message.toLowerCase();
  const memory = getConversationMemory(userInfo?.userId);

    if ((lowerMessage.includes('th·ªëng k√™') || lowerMessage.includes('s·ªë li·ªáu')) && 
      lowerMessage.includes('c·ªßa t√¥i')) {
    if (!userInfo?.userId) {
      return {
        type: 'special',
        content: 'auth_required',
        message: "üîê Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem th·ªëng k√™ c√° nh√¢n."
      };
    }
    
    try {
      let result;
      if (userInfo.role === 'user') {
        result = await callFunction('get_user_stats', { userId: userInfo.userId }, userInfo.role);
      } else if (userInfo.role === 'parking_owner') {
        result = await callFunction('get_owner_revenue', { userId: userInfo.userId }, userInfo.role);
      } else if (userInfo.role === 'admin') {
        result = await callFunction('get_admin_stats', { userId: userInfo.userId }, userInfo.role);
      }
      
      if (result.success) {
        return formatStatsResponse(userInfo.role, result.data);
      }
    } catch (error) {
      console.error('Error getting stats:', error);
    }
  }
  
  // X·ª≠ l√Ω ch√†o h·ªèi th√¥ng minh
  if (lowerMessage.includes('xin ch√†o') || lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
    let greeting = getRandomResponse(AI_PERSONALITY.conversationStyle.greeting);
    
    if (memory && memory.conversations.length > 0) {
      greeting = "üëã Ch√†o b·∫°n tr·ªü l·∫°i! T√¥i nh·ªõ ch√∫ng ta ƒë√£ n√≥i chuy·ªán r·ªìi. ";
    }
    
    if (userInfo?.role === 'guest') {
      greeting += "\n\nüéØ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ üîç T√¨m b√£i xe g·∫ßn b·∫°n\n‚Ä¢ üìÖ ƒê·∫∑t ch·ªó tr∆∞·ªõc\n‚Ä¢ ‚ùì Tr·∫£ l·ªùi c√°c c√¢u h·ªèi v·ªÅ d·ªãch v·ª•";
    } else {
      greeting += `\n\nüéØ Xin ch√†o ${userInfo.role}! T√¥i c√≥ th·ªÉ h·ªó tr·ª£:\n‚Ä¢ üîç T√¨m b√£i xe\n‚Ä¢ üìÖ ƒê·∫∑t ch·ªó nhanh ch√≥ng\n‚Ä¢ üìã Xem l·ªãch s·ª≠ booking\n‚Ä¢ üöó Qu·∫£n l√Ω xe ƒë√£ ƒëƒÉng k√Ω`;
    }
    
    updateConversationMemory(userInfo?.userId, message, greeting, { type: 'greeting' });
    return greeting;
  }

  // X·ª≠ l√Ω y√™u c·∫ßu xem xe ƒë√£ ƒëƒÉng k√Ω
  if (lowerMessage.includes('xe') && (lowerMessage.includes('ƒëƒÉng k√Ω') || lowerMessage.includes('c·ªßa t√¥i') || lowerMessage.includes('danh s√°ch'))) {
    if (!userInfo?.userId) {
      return {
        type: 'special',
        content: 'auth_required',
        message: "üîê " + getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " ƒê·ªÉ xem danh s√°ch xe, b·∫°n c·∫ßn ƒëƒÉng nh·∫≠p tr∆∞·ªõc nh√©!"
      };
    }
    
    try {
      const result = await callFunction('get_user_vehicles', { userId: userInfo.userId }, userInfo.role);
      let response;
      
      if (result.success) {
        if (result.data?.vehicles && result.data.vehicles.length > 0) {
          response = `üöó ${getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement)} ƒê√¢y l√† danh s√°ch xe ƒë√£ ƒëƒÉng k√Ω:\n\n` +
            result.data.vehicles.map((vehicle, i) => 
              `${i + 1}. üöô ${vehicle.licensePlate} (${vehicle.capacity || 'N/A'} ch·ªó)`
            ).join('\n') + 
            "\n\nüí° B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng b·∫•t k·ª≥ xe n√†o ƒë·ªÉ ƒë·∫∑t ch·ªó ƒë·ªó!";
        } else {
          response = "üö´ Hi·ªán t·∫°i b·∫°n ch∆∞a ƒëƒÉng k√Ω xe n√†o trong h·ªá th·ªëng.\n\nüí° H√£y th√™m xe ƒë·ªÉ c√≥ th·ªÉ ƒë·∫∑t ch·ªó d·ªÖ d√†ng h∆°n!";
        }
      } else {
        response = `‚ùå ${result.error || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin xe.'} B·∫°n th·ª≠ l·∫°i sau nh√©!`;
      }
      
      updateConversationMemory(userInfo?.userId, message, response, { type: 'vehicle_info', success: result.success });
      return response;
    } catch (error) {
      console.error('Error getting user vehicles:', error);
      return "‚ö†Ô∏è C√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin xe. " + getRandomResponse(AI_PERSONALITY.conversationStyle.empathy);
    }
  }

  // X·ª≠ l√Ω y√™u c·∫ßu xem l·ªãch s·ª≠ booking
  if (lowerMessage.includes('l·ªãch s·ª≠') || (lowerMessage.includes('booking') && lowerMessage.includes('c·ªßa t√¥i'))) {
    if (!userInfo?.userId) {
      return {
        type: 'special',
        content: 'auth_required',
        message: "üîê Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem l·ªãch s·ª≠ booking."
      };
    }
    
    try {
      const result = await callFunction('get_user_bookings', { 
        userId: userInfo.userId,
        limit: 10 
      }, userInfo.role);
      
      if (result.success) {
        if (result.data?.bookings && result.data.bookings.length > 0) {
          return `üìã L·ªãch s·ª≠ booking c·ªßa b·∫°n:\n` +
            result.data.bookings.map((booking, i) => 
              `${i + 1}. ${booking.parkingLotName || 'N/A'}\n   üöó ${booking.vehicleNumber}\n   üìÖ ${new Date(booking.startTime).toLocaleString('vi-VN')}\n   üí∞ ${booking.totalPrice?.toLocaleString() || 'N/A'}ƒë\n   üìä ${booking.status}`
            ).join('\n\n');
        } else {
          return "üì≠ B·∫°n ch∆∞a c√≥ booking n√†o.";
        }
      } else {
        return `‚ùå ${result.error || 'Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ booking.'}`;
      }
    } catch (error) {
      console.error('Error getting user bookings:', error);
      return "‚ö†Ô∏è C√≥ l·ªói x·∫£y ra khi l·∫•y l·ªãch s·ª≠ booking. Vui l√≤ng th·ª≠ l·∫°i.";
    }
  }

  // X·ª≠ l√Ω t√¨m ki·∫øm b√£i xe
  if (lowerMessage.includes('t√¨m') && lowerMessage.includes('b√£i')) {
    const location = extractLocation(message);
    if (location) {
      try {
        const result = await callFunction('search_parking_lots', { 
          location: location,
          limit: 5 
        }, userInfo?.role || 'guest');
        
        if (result.success && result.data && result.data.length > 0) {
          return `üè¢ T√¨m th·∫•y ${result.data.length} b√£i xe ·ªü ${location}:\n` +
            result.data.map((lot, i) => 
              `${i + 1}. ${lot.name}\n   üìç ${lot.address}\n   üí∞ ${lot.pricePerHour?.toLocaleString() || 'N/A'}ƒë/gi·ªù\n   üöó ${lot.availableSlots || 'N/A'} ch·ªó tr·ªëng`
            ).join('\n\n');
        } else {
          return `‚ùå Kh√¥ng t√¨m th·∫•y b√£i xe n√†o ·ªü ${location}. Th·ª≠ t√¨m ·ªü khu v·ª±c kh√°c?`;
        }
      } catch (error) {
        console.error('Error searching parking lots:', error);
        return "‚ö†Ô∏è C√≥ l·ªói x·∫£y ra khi t√¨m b√£i xe. Vui l√≤ng th·ª≠ l·∫°i.";
      }
    } else {
      return "üìç Vui l√≤ng cho bi·∫øt khu v·ª±c b·∫°n mu·ªën t√¨m b√£i xe (v√≠ d·ª•: 't√¨m b√£i xe ·ªü H·∫£i Ch√¢u')";
    }
  }

  // X·ª≠ l√Ω booking keywords
  const bookingKeywords = ['ƒë·∫∑t', 'book', 'booking', 'thu√™ ch·ªó', 'g·ª≠i xe'];
  const hasBookingKeyword = bookingKeywords.some(keyword => lowerMessage.includes(keyword));
  
  if (hasBookingKeyword) {
    if (!userInfo?.userId) {
      return {
        type: 'special',
        content: 'auth_required',
        message: "üîê " + getRandomResponse(AI_PERSONALITY.conversationStyle.empathy) + " ƒê·ªÉ ƒë·∫∑t ch·ªó, b·∫°n c·∫ßn ƒëƒÉng nh·∫≠p tr∆∞·ªõc nh√©!"
      };
    }

    const location = extractLocation(message);
    if (location) {
      try {
        const searchResult = await callFunction('search_parking_lots', { 
          location: location,
          limit: 3 
        }, userInfo.role);
        
        if (searchResult.success && searchResult.data && searchResult.data.length > 0) {
          const parkingLot = searchResult.data[0];
          
          let defaultVehicle = extractVehicleInfo(message);
          if (!defaultVehicle) {
            try {
              const vehicleResult = await callFunction('get_user_vehicles', { userId: userInfo.userId }, userInfo.role);
              if (vehicleResult.success && vehicleResult.data?.vehicles?.length > 0) {
                defaultVehicle = vehicleResult.data.vehicles[0].licensePlate;
              }
            } catch (error) {
              console.log('Could not get default vehicle:', error);
            }
          }
          
          const bookingData = {
            parkingLotId: parkingLot._id || parkingLot.id,
            parkingLotName: parkingLot.name,
            address: parkingLot.address,
            pricePerHour: parkingLot.pricePerHour,
            availableSlots: parkingLot.availableSlots,
            startTime: new Date(Date.now() + 30 * 60000).toISOString(),
            duration: 2,
            vehicleNumber: defaultVehicle || '',
            estimatedPrice: (parkingLot.pricePerHour || 10000) * 2
          };
          
          updateConversationMemory(userInfo.userId, message, '', { 
            type: 'booking_suggestion',
            pendingBooking: bookingData
          });
          
          return `üéØ ${getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement)} T√¨m th·∫•y b√£i xe ph√π h·ª£p!\n\n` +
            `üè¢ ${parkingLot.name}\n` +
            `üìç ${parkingLot.address}\n` +
            `üí∞ ${parkingLot.pricePerHour?.toLocaleString() || 'N/A'}ƒë/gi·ªù\n` +
            `üöó ${parkingLot.availableSlots || 'N/A'} ch·ªó tr·ªëng\n\n` +
            `üìã Th√¥ng tin ƒë·∫∑t ch·ªó:\n` +
            `üöô Xe: ${defaultVehicle || 'Ch∆∞a ch·ªçn'}\n` +
            `üìÖ Th·ªùi gian: ${new Date(bookingData.startTime).toLocaleString('vi-VN')}\n` +
            `‚è∞ Th·ªùi l∆∞·ª£ng: ${bookingData.duration} gi·ªù\n` +
            `üíµ T·ªïng ti·ªÅn: ${bookingData.estimatedPrice.toLocaleString()}ƒë\n\n` +
            `‚ùì B·∫°n c√≥ mu·ªën x√°c nh·∫≠n ƒë·∫∑t ch·ªó kh√¥ng? (Tr·∫£ l·ªùi "c√≥" ho·∫∑c "x√°c nh·∫≠n")`;
        }
      } catch (error) {
        console.error('Error in booking suggestion:', error);
        return "‚ö†Ô∏è C√≥ l·ªói x·∫£y ra khi t√¨m b√£i xe. " + getRandomResponse(AI_PERSONALITY.conversationStyle.empathy);
      }
    } else {
      return `üìç ${getRandomResponse(AI_PERSONALITY.conversationStyle.encouragement)} ƒê·ªÉ ƒë·∫∑t ch·ªó, h√£y cho t√¥i bi·∫øt:\n\n` +
        `üéØ **B·∫Øt bu·ªôc:**\n‚Ä¢ Khu v·ª±c (v√≠ d·ª•: "H·∫£i Ch√¢u", "Thanh Kh√™")\n\n` +
        `‚öôÔ∏è **T√πy ch·ªçn:**\n‚Ä¢ Th·ªùi gian b·∫Øt ƒë·∫ßu\n‚Ä¢ Th·ªùi l∆∞·ª£ng ƒë·ªó xe\n‚Ä¢ Bi·ªÉn s·ªë xe\n\n` +
        `üí° V√≠ d·ª•: "ƒê·∫∑t ch·ªó ·ªü H·∫£i Ch√¢u l√∫c 2 gi·ªù chi·ªÅu, ƒë·ªó 3 ti·∫øng"`;
    }
  }

  return null; // Chuy·ªÉn sang AI processing
}

// Th√™m h√†m format stats response
function formatStatsResponse(role, data) {
  switch (role) {
    case 'user':
      return `üìä **Th·ªëng k√™ c·ªßa b·∫°n:**\n` +
             `‚Ä¢ üìÖ S·ªë l∆∞·ª£t ƒë·∫∑t ch·ªó: ${data.bookingCount}\n` +
             `‚Ä¢ üöó S·ªë xe ƒë√£ ƒëƒÉng k√Ω: ${data.vehicleCount}\n` +
             `‚Ä¢ ‚è≥ ƒê·∫∑t ch·ªó ƒëang ho·∫°t ƒë·ªông: ${data.activeBookings}\n` +
             `‚Ä¢ üí∞ T·ªïng chi ti√™u: ${data.totalSpent?.toLocaleString() || 0}ƒë\n\n` +
             `üéØ Ti·∫øp t·ª•c kh√°m ph√° c√°c b√£i xe m·ªõi nh√©!`;
             
    case 'parking_owner':
      return `üè¢ **Th·ªëng k√™ doanh thu:**\n` +
             `‚Ä¢ üèóÔ∏è S·ªë b√£i xe qu·∫£n l√Ω: ${data.parkingLotCount}\n` +
             `‚Ä¢ üìà T·ªïng doanh thu: ${data.totalRevenue?.toLocaleString() || 0}ƒë\n` +
             `‚Ä¢ üìã T·ªïng s·ªë ƒë∆°n ƒë·∫∑t: ${data.totalBookings}\n` +
             `‚Ä¢ ‚úÖ ƒê∆°n ho√†n th√†nh: ${data.completedBookings}\n\n` +
             `üí° Doanh thu ·ªïn ƒë·ªãnh!`;
             
    case 'admin':
      return `üëë **Th·ªëng k√™ h·ªá th·ªëng:**\n` +
             `‚Ä¢ üë• T·ªïng ng∆∞·ªùi d√πng: ${data.totalUsers}\n` +
             `‚Ä¢ üè¢ T·ªïng ch·ªß b√£i xe: ${data.totalOwners}\n` +
             `‚Ä¢ üÖøÔ∏è T·ªïng b√£i xe: ${data.totalParkingLots}\n` +
             `‚Ä¢ üìÑ T·ªïng ƒë∆°n ƒë·∫∑t: ${data.totalBookings}\n` +
             `‚Ä¢ üíµ T·ªïng doanh thu: ${data.totalRevenue?.toLocaleString() || 0}ƒë\n\n` +
             `üåê H·ªá th·ªëng ƒëang ho·∫°t ƒë·ªông t·ªët!`;
             
    default:
      return "üìä Kh√¥ng c√≥ th·ªëng k√™ n√†o ƒë·ªÉ hi·ªÉn th·ªã.";
  }
}


// Helper functions
function extractLocation(message) {
  const patterns = [
    /(?:·ªü|t·∫°i|g·∫ßn|qu·∫≠n|huy·ªán|ph∆∞·ªùng)\s+([^,.!?\n]+)/i,
    /(\b(?:H·∫£i Ch√¢u|Thanh Kh√™|S∆°n Tr√†|Ng≈© H√†nh S∆°n|Li√™n Chi·ªÉu|C·∫©m L·ªá|H√≤a Vang)\b)/i,
    /(\b(?:qu·∫≠n|huy·ªán)\s+\d+\b)/i
  ];
  
  for (const pattern of patterns) {
    const match = message.match(pattern);
    if (match) return match[1].trim();
  }
  return null;
}

function extractVehicleInfo(message) {
  const vehiclePatterns = [
    /(?:xe|bi·ªÉn s·ªë)\s+([0-9]{2}[A-Z]-[0-9]{3,5})/i,
    /([0-9]{2}[A-Z]-[0-9]{3,5})/i
  ];
  
  for (const pattern of vehiclePatterns) {
    const match = message.match(pattern);
    if (match) {
      return match[1].toUpperCase();
    }
  }
  return null;
}

